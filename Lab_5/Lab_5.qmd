---
title: Исследование метаданных DNS трафика
author: "p.pluvkov@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы
1. Получить знания о методах исследования радиоэлектронной обстановки.
2. Составить представление о механизмах работы Wi-Fi сетей на канальном и сетевом уровне модели OSI.
3. Зекрепить практические навыки использования языка программирования R для обработки данных
4. Закрепить знания основных функций обработки данных экосистемы tidyverse языка R

## Исходные данные
1. Програмное обеспеченье MacOS
2. RStudio
3. Интерпретатор языка R 4.5.1
4. Файл P2_wifi_data.csv

## План

Используя программные пакеты dplyr и tidyverse проанализировать
журналы tcpdump и airodump-ng с помощью языка программирования R.

## Подготовка данных

0. Импорт библиотек
```{r setup, include=FALSE}
#| label: q1
options(repos = c(CRAN = "https://cloud.r-project.org/"))
```

```{r}
#| label: q2
library(tidyverse)
library(lubridate)
library(dplyr)
```
1. Загрузка данных
```{R}
Data <- read.csv('./P2_wifi_data.csv')
head(Data)
```

2. Привести датасеты в вид “аккуратных данных”, преобразовать типы столбцов в
соответствии с типом данных

```{r}
access_points <- read.csv('./P2_wifi_data.csv', nrows = 167, stringsAsFactors = FALSE)
access_points$First.time.seen <- as.POSIXct(access_points$First.time.seen, format="%Y-%m-%d %H:%M:%S")
access_points$Last.time.seen  <- as.POSIXct(access_points$Last.time.seen, format="%Y-%m-%d %H:%M:%S")
access_points$channel         <- as.integer(access_points$channel)
access_points$Speed           <- as.numeric(access_points$Speed)
access_points$Power           <- as.numeric(access_points$Power)
access_points$X..beacons      <- as.integer(access_points$X..beacons)
access_points$X..IV           <- as.numeric(access_points$X..IV)
access_points$ESSID <- as.character(access_points$ESSID)
access_points$Key   <- as.character(access_points$Key)

client_requests <- read.csv('./P2_wifi_data.csv', skip = 169, stringsAsFactors = FALSE)
client_requests$First.time.seen <- as.POSIXct(client_requests$First.time.seen, format="%Y-%m-%d %H:%M:%S")
client_requests$Last.time.seen  <- as.POSIXct(client_requests$Last.time.seen, format="%Y-%m-%d %H:%M:%S")
client_requests$Power           <- as.numeric(client_requests$Power)
client_requests$X..packets      <- as.integer(client_requests$X..packets)
client_requests$BSSID           <- as.character(client_requests$BSSID)
client_requests$Probed.ESSIDs   <- as.character(client_requests$Probed.ESSIDs)
client_requests$Station.MAC     <- as.character(client_requests$Station.MAC)
```

3. Просмотрите общую структуру данных с помощью функции glimpse()

```{R}
glimpse(access_points)
glimpse(client_requests)
```

## Анализ данныз

### Шаг 1. Определить небезопасные точки доступа (без шифрования – OPN)

```{R}
AP_nOPN <- access_points %>% filter(str_detect(toupper(Privacy), "OPN")) %>% select(BSSID)
AP_nOPN
```

### Шаг 2. Определить производителя для каждого обнаруженного устройства
```{R}
oui_raw <- readLines("oui.txt")
pattern <- "^([0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2})\\s+\\(hex\\)\\s+(.+)$"
matches <- regexec(pattern, oui_raw)
parsed <- regmatches(oui_raw, matches)
parsed <- parsed[sapply(parsed, length) == 3]
oui_df <- data.frame(
  OUI = toupper(gsub("-", ":", sapply(parsed, `[`, 2))),
  Manufacturer = sapply(parsed, `[`, 3),
  stringsAsFactors = FALSE
)

AP_nOPN$OUI <- toupper(substr(AP_nOPN$BSSID, 1, 8))
AP_nOPN <- merge(AP_nOPN, oui_df, by="OUI", all.x=TRUE)
AP_nOPN$Manufacturer[is.na(AP_nOPN$Manufacturer)] <- "Unknown"
head(AP_nOPN)
```
### Шаг 3. Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах

```{R}
access_points %>%
  filter(str_detect(toupper(Privacy), "WPA3")) %>%
  select(BSSID, ESSID) %>%
  distinct()
```

### Шаг 4. Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.
```{r}
access_points %>% 
  mutate(duration = as.numeric(
    difftime(Last.time.seen, First.time.seen, units = "secs"))
    ) %>% 
  arrange(desc(duration)) %>% select(BSSID, duration) %>% head(10)
```

### Шаг 5. Обнаружить топ-10 самых быстрых точек доступа.

```{R}
access_points %>% arrange(desc(Speed)) %>% head(10)
```

### Шаг 6. Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию.

```{R}
library(dplyr)

access_points %>%
  mutate(
    duration = as.numeric(difftime(Last.time.seen, First.time.seen, units = "secs")),
    beacons_per_second = X..beacons / duration
  ) %>%
  filter(duration != 0) %>%
  arrange(desc(beacons_per_second)) %>%
  select(BSSID, beacons_per_second) %>%
  head()
```


## Данные клиентов

1. Определить производителя для каждого обнаруженного устройства
```{R}
Unique_Tech <- unique(client_requests$BSSID)
oui <- read.table(
  "oui.txt",
  sep = "\t",
  fill = TRUE,
  quote = "",
  stringsAsFactors = FALSE,
  col.names = c("OUI_raw", "Type", "Manufacturer")
)
oui$OUI <- toupper(gsub("-", ":", trimws(oui$OUI_raw)))
oui$OUI <- sub("\\s+.*", "", oui$OUI)   # убираем " (hex)"
clean_mac <- function(x) {
  x <- toupper(trimws(x))
  if (grepl("^([0-9A-F]{2}:){5}[0-9A-F]{2}$", x)) x else NA
}
extract_oui <- function(mac) {
  if (is.na(mac)) return(NA)
  paste(strsplit(mac, ":")[[1]][1:3], collapse=":")
}
find_man <- function(oui_prefix) {
  if (is.na(oui_prefix)) return("Unknown")
  m <- oui$Manufacturer[oui$OUI == oui_prefix]
  if (length(m) == 0) "Unknown" else m
}
mac_clean <- sapply(Unique_Tech, clean_mac)
mac_oui   <- sapply(mac_clean, extract_oui)
manufs    <- sapply(mac_oui, find_man)

result <- data.frame(
  OUI = mac_oui,
  Manufacturer = manufs
)

result
```

2. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес
```{R}
library(dplyr)
library(stringr)

NotUniqueDevice <- client_requests %>%
  filter(!is.na(Station.MAC)) %>%                         # убираем пустые
  filter(!toupper(substr(Station.MAC, 2, 2)) %in% c("2","6","A","E")) %>%  # локальный бит
  select(Station.MAC) %>%
  distinct()  

head(NotUniqueDevice)
```


3. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее.

```{R}
library(dplyr)

grouped_data <- client_requests %>%
  group_by(Probed.ESSIDs) %>%
  summarise(
    unique_devices = n_distinct(Station.MAC),
    first_time_seen = min(First.time.seen, na.rm = TRUE),
    last_time_seen  = max(Last.time.seen, na.rm = TRUE),
    .groups = "drop"
  )

head(grouped_data)
```

4. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.

```{R}
library(dplyr)

shortest_sd_essid <- client_requests %>%
  mutate(duration = as.integer(difftime(Last.time.seen, First.time.seen, units = "secs"))) %>%
  filter(duration != 0, !is.na(Probed.ESSIDs)) %>%
  group_by(Probed.ESSIDs) %>%
  summarise(
    Mean = mean(duration, na.rm = TRUE),
    Sd   = sd(duration, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(!is.na(Sd) & Sd != 0) %>%
  arrange(Sd) %>%
  select(Probed.ESSIDs, Mean, Sd) %>%
  slice_head(n = 1)

shortest_sd_essid
```

## Оценка результатов
Используя программные пакеты dplyr и tidyverse проанализировали
журналы tcpdump и airodump-ng с помощью языка программирования R.

## Вывод
1. Получили знания о методах исследования радиоэлектронной обстановки.
2. Составили представление о механизмах работы Wi-Fi сетей на канальном и сетевом уровне модели OSI.
3. Зекрепили практические навыки использования языка программирования R для обработки данных
4. Закрепили знания основных функций обработки данных экосистемы tidyverse языка R
















