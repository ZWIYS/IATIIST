---
title: Исследование метаданных DNS трафика
author: "p.pluvkov@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы
1. Получить знания о методах исследования радиоэлектронной обстановки.
2. Составить представление о механизмах работы Wi-Fi сетей на канальном и сетевом уровне модели OSI.
3. Зекрепить практические навыки использования языка программирования R для обработки данных
4. Закрепить знания основных функций обработки данных экосистемы tidyverse языка R

## Исходные данные
1. Програмное обеспеченье MacOS
2. RStudio
3. Интерпретатор языка R 4.5.1
4. Файл P2_wifi_data.csv

## План

Используя программные пакеты dplyr и tidyverse проанализировать
журналы tcpdump и airodump-ng с помощью языка программирования R.

## Подготовка данных

0. Импорт библиотек
```{r setup, include=FALSE}
#| label: q1
options(repos = c(CRAN = "https://cloud.r-project.org/"))
```

```{r}
#| label: q2
library(tidyverse)
library(lubridate)
library(dplyr)
library(stringr)
```
1. Загрузка и подготовка данных
```{R}
# Чтение данных о точках доступа
access_points <- read_csv(
  'P2_wifi_data.csv',
  n_max = 167,
  col_types = cols(
    .default = col_character(),
    First.time.seen = col_datetime(format = "%Y-%m-%d %H:%M:%S"),
    Last.time.seen = col_datetime(format = "%Y-%m-%d %H:%M:%S"),
    Channel = col_integer(),
    Speed = col_number(),
    Power = col_number(),
    `# beacons` = col_integer(),
    `# IV` = col_number()
  )
)

# Чтение данных о клиентах
client_requests <- read_csv(
  'P2_wifi_data.csv',
  skip = 169,
  col_types = cols(
    .default = col_character(),
    First.time.seen = col_datetime(format = "%Y-%m-%d %H:%M:%S"),
    Last.time.seen = col_datetime(format = "%Y-%m-%d %H:%M:%S"),
    Power = col_number(),
    `# packets` = col_integer()
  )
)

# Переименование столбцов для удобства
access_points <- access_points %>%
  rename(
    beacons = `# beacons`,
    iv_count = `# IV`
  )

client_requests <- client_requests %>%
  rename(
    packets = `# packets`
  )

glimpse(access_points)
glimpse(client_requests)
```

## Анализ данныз

### Шаг 1. Определить небезопасные точки доступа (без шифрования – OPN)

```{R}
AP_nOPN <- access_points %>% filter(str_detect(toupper(Privacy), "OPN")) %>% select(BSSID, ESSID)
AP_nOPN
```

### Шаг 2. Определить производителя для каждого обнаруженного устройства
```{R}
oui_raw <- readLines("oui.txt")
pattern <- "^([0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2})\\s+\\(hex\\)\\s+(.+)$"
matches <- regexec(pattern, oui_raw)
parsed <- regmatches(oui_raw, matches)
parsed <- parsed[sapply(parsed, length) == 3]
oui_df <- data.frame(
  OUI = toupper(gsub("-", ":", sapply(parsed, `[`, 2))),
  Manufacturer = sapply(parsed, `[`, 3),
  stringsAsFactors = FALSE
)

AP_nOPN$OUI <- toupper(substr(AP_nOPN$BSSID, 1, 8))
AP_nOPN <- merge(AP_nOPN, oui_df, by="OUI", all.x=TRUE)
AP_nOPN$Manufacturer[is.na(AP_nOPN$Manufacturer)] <- "Unknown"
head(AP_nOPN)
```
### Шаг 3. Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах

```{R}
wpa3_devices <- access_points %>%
  filter(str_detect(toupper(Privacy), "WPA3")) %>%
  select(BSSID, ESSID, Privacy, Cipher, Speed, channel) %>%
  arrange(desc(Speed))

  print(wpa3_devices)
```

### Шаг 4. Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.
```{r}
print(sapply(access_points, class)[grepl("time|Time|seen|Seen", names(access_points))])

access_points_times <- access_points %>%
  mutate(
    first_seen = as.POSIXct(`First time seen`, format = "%Y-%m-%d %H:%M:%S"),
    last_seen = as.POSIXct(`Last time seen`, format = "%Y-%m-%d %H:%M:%S")
  )


ap_activity <- access_points_times %>%
  mutate(
    activity_duration = as.numeric(
      difftime(last_seen, first_seen, units = "hours")
    )
  ) %>%
  filter(activity_duration > 0) %>%
  select(BSSID, ESSID, first_seen, last_seen, activity_duration, channel) %>%
  arrange(desc(activity_duration))

ap_activity %>%
  head(10) %>%
  mutate(
    activity_duration = round(activity_duration, 2),
    first_time = format(first_seen, "%H:%M"),
    last_time = format(last_seen, "%H:%M")
  ) %>%
  select(BSSID, ESSID, channel, first_time, last_time, activity_duration)
```

### Шаг 5. Обнаружить топ-10 самых быстрых точек доступа.

```{R}
access_points %>% arrange(desc(Speed)) %>% head(10)
```

### Шаг 6. Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию.

```{R}
access_points_times <- access_points %>%
  mutate(
    first_seen = as.POSIXct(`First time seen`, format = "%Y-%m-%d %H:%M:%S"),
    last_seen = as.POSIXct(`Last time seen`, format = "%Y-%m-%d %H:%M:%S")
  )


beacon_stats <- access_points_times %>%
  mutate(
    duration_sec = as.numeric(
      difftime(last_seen, first_seen, units = "secs")
    ),
    beacons_per_sec = if_else(
      duration_sec > 0,
      beacons / duration_sec,
      NA_real_
    )
  ) %>%
  filter(!is.na(beacons_per_sec) & beacons_per_sec > 0) %>%
  select(BSSID, ESSID, beacons, duration_sec, beacons_per_sec, channel) %>%
  arrange(desc(beacons_per_sec))

cat("### Интенсивность отправки beacon-фреймов (топ-10):\n")
if(nrow(beacon_stats) > 0) {
  beacon_stats %>%
    head(10) %>%
    mutate(
      beacons_per_sec = round(beacons_per_sec, 2),
      duration_min = round(duration_sec / 60, 1)
    ) %>%
    select(BSSID, ESSID, channel, beacons, duration_min, beacons_per_sec)
} else {
  cat("Нет данных для анализа beacon-фреймов.\n")
}
```


## Данные клиентов

1. Определить производителя для каждого обнаруженного устройства
```{R}
Unique_Tech <- unique(client_requests$BSSID)
oui <- read.table(
  "oui.txt",
  sep = "\t",
  fill = TRUE,
  quote = "",
  stringsAsFactors = FALSE,
  col.names = c("OUI_raw", "Type", "Manufacturer")
)
oui$OUI <- toupper(gsub("-", ":", trimws(oui$OUI_raw)))
oui$OUI <- sub("\\s+.*", "", oui$OUI)   # убираем " (hex)"
clean_mac <- function(x) {
  x <- toupper(trimws(x))
  if (grepl("^([0-9A-F]{2}:){5}[0-9A-F]{2}$", x)) x else NA
}
extract_oui <- function(mac) {
  if (is.na(mac)) return(NA)
  paste(strsplit(mac, ":")[[1]][1:3], collapse=":")
}
find_man <- function(oui_prefix) {
  if (is.na(oui_prefix)) return("Unknown")
  m <- oui$Manufacturer[oui$OUI == oui_prefix]
  if (length(m) == 0) "Unknown" else m
}
mac_clean <- sapply(Unique_Tech, clean_mac)
mac_oui   <- sapply(mac_clean, extract_oui)
manufs    <- sapply(mac_oui, find_man)

result <- data.frame(
  OUI = mac_oui,
  Manufacturer = manufs
)

result
```

2. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес
```{R}
is_global_mac <- function(mac) {
  if (is.na(mac) || mac == "" || mac == "(not associated)") return(FALSE)
  
  mac_clean <- gsub("[-: ]", "", toupper(mac))

  if (!grepl("^[0-9A-F]{12}$", mac_clean)) return(FALSE)
  
  first_octet_hex <- substr(mac_clean, 1, 2)
  first_octet_bin <- strtoi(first_octet_hex, base = 16)
  
  local_bit <- bitwAnd(first_octet_bin, 0x02) != 0
  
  return(!local_bit) 
}

devices_real_mac <- client_requests %>%
  filter(!is.na(`Station MAC`) & `Station MAC` != "(not associated)") %>%
  mutate(
    is_global = map_lgl(`Station MAC`, is_global_mac)
  ) %>%
  filter(is_global) %>%
  select(`Station MAC`, BSSID, `Probed ESSIDs`, Power) %>%
  distinct()


if(nrow(devices_real_mac) > 0) {
  devices_real_mac

} 



mac_stats <- client_requests %>%
  filter(!is.na(`Station MAC`) & `Station MAC` != "(not associated)") %>%
  summarise(
    total_devices = n_distinct(`Station MAC`),
    global_macs = sum(map_lgl(`Station MAC`, is_global_mac), na.rm = TRUE),
    percentage_global = round(global_macs / total_devices * 100, 1)
  )

```


3. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее.

```{R}
client_clusters <- client_requests %>%
  filter(!is.na(`Probed ESSIDs`) & `Probed ESSIDs` != "") %>%
  mutate(
    first_time = as.POSIXct(`First time seen`, format = "%Y-%m-%d %H:%M:%S"),
    last_time = as.POSIXct(`Last time seen`, format = "%Y-%m-%d %H:%M:%S")
  ) %>%
  group_by(`Probed ESSIDs`) %>%
  summarise(
    device_count = n_distinct(`Station MAC`),
    first_detection = min(first_time, na.rm = TRUE),  
    last_detection = max(last_time, na.rm = TRUE),    
    avg_power = mean(Power, na.rm = TRUE),
    total_packets = sum(packets, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    observation_period = as.numeric(
      difftime(last_detection, first_detection, units = "hours")
    )
  ) %>%
  arrange(desc(device_count))

if(nrow(client_clusters) > 0) {
  result <- client_clusters %>%
    mutate(
      first_time_str = format(first_detection, "%H:%M"),
      last_time_str = format(last_detection, "%H:%M"),
      observation_period = round(observation_period, 2),
      avg_power = round(avg_power, 1)
    ) %>%
    select(
      `Probed ESSIDs`, 
      device_count, 
      first_time_str, 
      last_time_str, 
      observation_period, 
      avg_power, 
      total_packets
    )
  result}
```

4. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.

```{R}
shortest_sd_essid <- client_requests %>%
  mutate(
    first_time = as.POSIXct(`First time seen`, format = "%Y-%m-%d %H:%M:%S"),
    last_time = as.POSIXct(`Last time seen`, format = "%Y-%m-%d %H:%M:%S"),
    duration = as.numeric(difftime(last_time, first_time, units = "secs"))
  ) %>%
  filter(duration > 0 & !is.na(`Probed ESSIDs`) & `Probed ESSIDs` != "") %>%
  group_by(`Probed ESSIDs`) %>%
  summarise(
    Mean = mean(duration, na.rm = TRUE),
    Sd = sd(duration, na.rm = TRUE),
    Count = n(),
    .groups = "drop"
  ) %>%
  filter(!is.na(Sd) & Sd > 0) %>%
  arrange(Sd) %>%
  select(`Probed ESSIDs`, Count, Mean, Sd) %>%
  head(1)  # Берем только самую стабильную
if(nrow(shortest_sd_essid) > 0) {
  result <- shortest_sd_essid %>%
    mutate(
      Mean_min = round(Mean / 60, 2),
      Sd_min = round(Sd / 60, 2),
      `Probed ESSIDs` = if_else(
        nchar(`Probed ESSIDs`) > 40,
        paste0(substr(`Probed ESSIDs`, 1, 37), "..."),
        `Probed ESSIDs`))
      
      result}
```

## Оценка результатов
Используя программные пакеты dplyr и tidyverse проанализировали
журналы tcpdump и airodump-ng с помощью языка программирования R.

## Вывод
1. Получили знания о методах исследования радиоэлектронной обстановки.
2. Составили представление о механизмах работы Wi-Fi сетей на канальном и сетевом уровне модели OSI.
3. Зекрепили практические навыки использования языка программирования R для обработки данных
4. Закрепили знания основных функций обработки данных экосистемы tidyverse языка R
















